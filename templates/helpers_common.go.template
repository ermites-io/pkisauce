//go:build go1.17
// +build go1.17
//
// {{ $date := .Time }}
//
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
// THIS FILE IS GENERATED BY PkiSauce! DO NOT EDIT!
//
// Generated: {{ $date }}

/*
 *
 * BSD 3-Clause License
 * 
 * Copyright (c) 2020 Eric Aug√© <eau [plus] pkisauce [a.t.] unix4fun [D.O.T] net> as Ermites.IO
 * All rights reserved.
 * 
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package main

import (
	//"bytes"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	//"encoding/gob"
	"fmt"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var (
	ErrPkscGrpcAuthz = status.Errorf(codes.PermissionDenied, "invalid authorization")
	ErrPkscParse     = fmt.Errorf("parse error")
	ErrPkscAuthz     = fmt.Errorf("invalid authorization")
	ErrPkscEINVAL    = fmt.Errorf("invalid valuer")

	// policy related..
        pkscb64 = base64.RawURLEncoding
        wc  = "*"
)

type NodePkiInfo map[string]string

type ClientTlsConfigParamsMap map[string]struct {
	Ca, Cert, Key string
	UUID string
	Verify func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error
}

// lookup & exec the right tls client config 
func (tcm ClientTlsConfigParamsMap) TlsConfigByName(dstname string) (*tls.Config, error) {
	s, ok := tcm[dstname]
	if ok {
		return pkscTlsClientConfig(s.Ca, s.Cert, s.Key, s.UUID, s.Verify)
	}

	return nil, ErrPkscEINVAL
}

type GrpcDialoptFuncMap map[string]func(p ...string)(grpc.DialOption, error)
// lookup & exec the right tls client dialopt
func (gdm GrpcDialoptFuncMap) DialOptByName(dstname string) (grpc.DialOption, error) {
	f, ok := gdm[dstname]
	if ok {
		return f()
	}

	return nil, ErrPkscEINVAL
}

//
// POLICY RELATED
//

type RPCs map[string]bool
type Services map[string]RPCs
type Hosts map[string]Services

type Policy struct {
        wc string
        ph *Hasher
        h  Hosts
}

func (r RPCs) check(wc, call string) bool {
        // handle wildcard.
        _, ok := r[wc]
        if ok {
                return true
        }

        _, ok = r[call]
        return ok
}

func (s Services) check(wc, svc, call string) bool {
        // handle wildcard.
        rpcs, ok := s[wc]
        if ok {
                if rpcs.check(wc, call) {
                        return true
                }
        }

        rpcs, ok = s[svc]
        if ok {
                return rpcs.check(wc, call)
        }

        return false
}

func (h Hosts) check(wc, host, svc, call string) bool {
        // handle wildcard.
        s, ok := h[wc]
        if ok {
                if s.check(wc, svc, call) {
                        return true
                }
        }

        // no matching wildcards.
        s, ok = h[host]
        if ok {
                return s.check(wc, svc, call)
        }

        return false
}

func (h Hosts) isCallAuthorized(wc, cn, svc, call string) bool {
        return h.check(wc, cn, svc, call)
}

func (h Hosts) isHostAuthorized(wc, cn string) bool {
	_, ok := h[wc]
	if ok {
		return true
	}

	_, ok = h[cn]
	if ok {
		return true
	}

	return false
}


/*
func unmarshal(key []byte, blob64 string) (h Hosts, err error) {
	h = make(Hosts)
	blob, err := b64.DecodeString(blob64)
	if err != nil {
		return
	}
	// TODO decrypt here.
	//
	bh := bytes.NewBuffer(blob)
	dec := gob.NewDecoder(bh)
	err = dec.Decode(&h)
	return
}
*/


// this function is used when called from gRPC policies compiled map

// TODO XXX needs fuzzing.
// we are parsing /main.Public/CallMe or /main.v1.Public/CallMe
// fast, not safe, but safe enough since this arrives through parsed handlers of GRPC
// DO NOT USE that front facing, it is NOT input sanitization yet.
// wrapping uint might trigger a vulnerable function, but good enough
// /test/toto parts == 3
// parts[0] = ""
// parts[1] = test.prout
// parts[1] = test.v1.prout (if proto uses version)
// parts[2] = toto
func parseGrpcMethod(fullmethod string) (pkg, svc, call string, err error) {
	if len(fullmethod) > 1024 {
		err = ErrPkscParse
		return
	}

	fullMethodFields := strings.Split(fullmethod, "/")
	if len(fullMethodFields) != 3 {
		err = ErrPkscParse
		return
	}

	// if the package contains a version, then we will have 3 parts
	// if it doesn't, then only two.
	pkgSvcFields := strings.Split(fullMethodFields[1], ".")
	switch len(pkgSvcFields) {
		case 2:
			pkg = pkgSvcFields[0]
			svc = pkgSvcFields[1]
		case 3:
			// we skip the version located in fields[1]
			// we will support it in a future version.
			pkg = pkgSvcFields[0]
			svc = pkgSvcFields[2]
		default:
			err = ErrPkscParse
			return
	}

	call = fullMethodFields[2]

	if len(pkg) == 0 || len(svc) == 0 || len(call) == 0 {
		err = ErrPkscParse
		return
	}

	isAlNum := func(s string) {
		for i := 0; i < len(s); i++ {
			switch {
			case s[i] < 0x30: // char: 0
				fallthrough
			case s[i] > 0x7a: // char: z
				fallthrough
			case s[i] > 0x39 && s[i] < 0x41: // char: 9 - char: A
				fallthrough
			case s[i] > 0x5a && s[i] < 0x61: // char: Z - char: a
				err = ErrPkscParse
				return
			}
		}
	}

	isAlNum(pkg)
	isAlNum(svc)
	isAlNum(call)
	return
}

func pkscTlsServConfig(PEMca, PEMcert, PEMkey string, 
		verifyPeer func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error) (tlsconf *tls.Config, err error) {
	certificate, err := tls.X509KeyPair([]byte(PEMcert), []byte(PEMkey))
	if err != nil {
		return nil, err
	}

	// TODO exit the pool to be global to the file we need to load only
	// once..
	caPool := x509.NewCertPool()
	ok := caPool.AppendCertsFromPEM([]byte(PEMca))
	if !ok {
		err = ErrPkscParse
		return
	}

	tlsconf = &tls.Config{
		ClientAuth:         tls.RequireAndVerifyClientCert,
		Certificates:       []tls.Certificate{certificate},
		ClientCAs:          caPool,
		InsecureSkipVerify: false,
		// XXX this handler is NOT necessary for GRPC, since you have the interceptor
		// but for normal sockets with single cert it's the basic client verification
		VerifyPeerCertificate: verifyPeer,
		MinVersion: tls.VersionTLS13,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
			tls.TLS_AES_128_GCM_SHA256,
			tls.TLS_AES_256_GCM_SHA384,
			tls.TLS_CHACHA20_POLY1305_SHA256},
	}

	return
}

func pkscTlsClientConfig(PEMca, PEMcert, PEMkey, serverName string,
		verifyPeer func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error) (tlsconf *tls.Config, err error) {

        certificate, err := tls.X509KeyPair([]byte(PEMcert), []byte(PEMkey))
        if err != nil {
                return
        }

        // TODO exit the pool to be global to the file we need to load only
        // once..
        caPool := x509.NewCertPool()
        ok := caPool.AppendCertsFromPEM([]byte(PEMca))
        if !ok {
		err = ErrPkscParse
                return
        }

        tlsconf = &tls.Config{
                ServerName:         serverName,
                ClientAuth:         tls.RequireAndVerifyClientCert,
                Certificates:       []tls.Certificate{certificate},
                RootCAs:            caPool,
                InsecureSkipVerify: false,
		VerifyPeerCertificate: verifyPeer,
                MinVersion:         tls.VersionTLS13,
                CipherSuites: []uint16{
                        tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
                        tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
                        tls.TLS_AES_128_GCM_SHA256,
                        tls.TLS_AES_256_GCM_SHA384,
                        tls.TLS_CHACHA20_POLY1305_SHA256},
        }

	return
}

/*
func pkscGrpcCredsServ(PEMca, PEMcert, PEMkey string, 
		verifyPeer func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error) (credentials.TransportCredentials, error) {
	tlsConfig, err := pkscTlsServConfig(PEMca, PEMcert, PEMkey, verifyPeer)
	return credentials.NewTLS(tlsConfig), err
}

func pkscGrpcCredsClient(PEMca, PEMcert, PEMkey, toServerName string) (credentials.TransportCredentials, error) {
	tlsConfig, err := pkscTlsClientConfig(PEMca, PEMcert, PEMkey, toServerName)
        return credentials.NewTLS(tlsConfig), err
}
*/

