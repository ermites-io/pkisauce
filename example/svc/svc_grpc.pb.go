// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package svc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PublicClient is the client API for Public service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicClient interface {
	CallMe(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type publicClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicClient(cc grpc.ClientConnInterface) PublicClient {
	return &publicClient{cc}
}

func (c *publicClient) CallMe(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Public/CallMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicClient) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Public/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicServer is the server API for Public service.
// All implementations should embed UnimplementedPublicServer
// for forward compatibility
type PublicServer interface {
	CallMe(context.Context, *Request) (*Response, error)
	Ping(context.Context, *Request) (*Response, error)
}

// UnimplementedPublicServer should be embedded to have forward compatible implementations.
type UnimplementedPublicServer struct {
}

func (UnimplementedPublicServer) CallMe(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallMe not implemented")
}
func (UnimplementedPublicServer) Ping(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

// UnsafePublicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicServer will
// result in compilation errors.
type UnsafePublicServer interface {
	mustEmbedUnimplementedPublicServer()
}

func RegisterPublicServer(s grpc.ServiceRegistrar, srv PublicServer) {
	s.RegisterService(&Public_ServiceDesc, srv)
}

func _Public_CallMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicServer).CallMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Public/CallMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicServer).CallMe(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Public_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Public/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicServer).Ping(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Public_ServiceDesc is the grpc.ServiceDesc for Public service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Public_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.Public",
	HandlerType: (*PublicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CallMe",
			Handler:    _Public_CallMe_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Public_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "svc.proto",
}

// RestrictedClient is the client API for Restricted service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RestrictedClient interface {
	CallHere(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	CallThere(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type restrictedClient struct {
	cc grpc.ClientConnInterface
}

func NewRestrictedClient(cc grpc.ClientConnInterface) RestrictedClient {
	return &restrictedClient{cc}
}

func (c *restrictedClient) CallHere(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Restricted/CallHere", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *restrictedClient) CallThere(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Restricted/CallThere", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RestrictedServer is the server API for Restricted service.
// All implementations should embed UnimplementedRestrictedServer
// for forward compatibility
type RestrictedServer interface {
	CallHere(context.Context, *Request) (*Response, error)
	CallThere(context.Context, *Request) (*Response, error)
}

// UnimplementedRestrictedServer should be embedded to have forward compatible implementations.
type UnimplementedRestrictedServer struct {
}

func (UnimplementedRestrictedServer) CallHere(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallHere not implemented")
}
func (UnimplementedRestrictedServer) CallThere(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallThere not implemented")
}

// UnsafeRestrictedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RestrictedServer will
// result in compilation errors.
type UnsafeRestrictedServer interface {
	mustEmbedUnimplementedRestrictedServer()
}

func RegisterRestrictedServer(s grpc.ServiceRegistrar, srv RestrictedServer) {
	s.RegisterService(&Restricted_ServiceDesc, srv)
}

func _Restricted_CallHere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RestrictedServer).CallHere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Restricted/CallHere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RestrictedServer).CallHere(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Restricted_CallThere_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RestrictedServer).CallThere(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Restricted/CallThere",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RestrictedServer).CallThere(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Restricted_ServiceDesc is the grpc.ServiceDesc for Restricted service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Restricted_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.Restricted",
	HandlerType: (*RestrictedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CallHere",
			Handler:    _Restricted_CallHere_Handler,
		},
		{
			MethodName: "CallThere",
			Handler:    _Restricted_CallThere_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "svc.proto",
}

// DifferentClient is the client API for Different service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DifferentClient interface {
	CallDifferent(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Shazz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type differentClient struct {
	cc grpc.ClientConnInterface
}

func NewDifferentClient(cc grpc.ClientConnInterface) DifferentClient {
	return &differentClient{cc}
}

func (c *differentClient) CallDifferent(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Different/CallDifferent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *differentClient) Shazz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/main.Different/Shazz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DifferentServer is the server API for Different service.
// All implementations should embed UnimplementedDifferentServer
// for forward compatibility
type DifferentServer interface {
	CallDifferent(context.Context, *Request) (*Response, error)
	Shazz(context.Context, *Request) (*Response, error)
}

// UnimplementedDifferentServer should be embedded to have forward compatible implementations.
type UnimplementedDifferentServer struct {
}

func (UnimplementedDifferentServer) CallDifferent(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallDifferent not implemented")
}
func (UnimplementedDifferentServer) Shazz(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shazz not implemented")
}

// UnsafeDifferentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DifferentServer will
// result in compilation errors.
type UnsafeDifferentServer interface {
	mustEmbedUnimplementedDifferentServer()
}

func RegisterDifferentServer(s grpc.ServiceRegistrar, srv DifferentServer) {
	s.RegisterService(&Different_ServiceDesc, srv)
}

func _Different_CallDifferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DifferentServer).CallDifferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Different/CallDifferent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DifferentServer).CallDifferent(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Different_Shazz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DifferentServer).Shazz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.Different/Shazz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DifferentServer).Shazz(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Different_ServiceDesc is the grpc.ServiceDesc for Different service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Different_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.Different",
	HandlerType: (*DifferentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CallDifferent",
			Handler:    _Different_CallDifferent_Handler,
		},
		{
			MethodName: "Shazz",
			Handler:    _Different_Shazz_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "svc.proto",
}
